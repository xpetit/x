package x

import (
	"cmp"
	"fmt"
	"io"
	"math"
	"slices"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"
)

var (
	once  sync.Once
	cache map[rune]string
)

// InitUnicodeCategory inits the cache for UnicodeCategory
// It is exported so that the user can trigger cache building instead of waiting for the first call to UnicodeCategory.
func InitUnicodeCategory() {
	once.Do(func() {
		cache = map[rune]string{}
		for category, rt := range unicode.Categories {
			if len(category) == 2 {
				for _, r16 := range rt.R16 {
					for r := rune(r16.Lo); r <= rune(r16.Hi); r += rune(r16.Stride) {
						cache[r] = category
					}
				}
				for _, r32 := range rt.R32 {
					for r := rune(r32.Lo); r <= rune(r32.Hi); r += rune(r32.Stride) {
						cache[r] = category
					}
				}
			}
		}
	})
}

// UnicodeCategory returns the code point General Category.
// It is a two bytes string with major & minor e.g. "Lu", "Zs", "Nd"...
func UnicodeCategory(r rune) (name string) {
	InitUnicodeCategory()
	return cache[r]
}

func AppendUnicodeBar(b []byte, width int) []byte {
	b = slices.Grow(b, 3*((7+width)/8))
	for i := 0; i < width/8; i++ {
		b = utf8.AppendRune(b, '█')
	}
	if rem := width % 8; rem > 0 {
		b = utf8.AppendRune(b, [...]rune{1: '▏', '▎', '▍', '▌', '▋', '▊', '▉'}[rem])
	}
	return b
}

func UnicodeBar(width int) string {
	return string(AppendUnicodeBar(nil, width))
}

func keyString[T comparable](a T) string {
	switch a := any(a).(type) {
	case string:
		return a

	case rune:
		if a <= unicode.MaxASCII {
			return string(a)
		}
		return strconv.QuoteRune(a)
	}

	return fmt.Sprint(a)
}

// BarChart prints a bar chart with unicode block elements to help visualize m in a compact way.
// If maxItems > -1, it limits the amount of lines to display.
// Example with the number of online players for 8 games (data from steamcharts):
//
//	100%  2405676  Total (8 entries)
//	 50%  1195540  Counter-Strike: Global Offensive [██████      ]
//	 20%   473708  Dota 2                           [██▍         ]
//	 11%   275232  Apex Legends                     [█▍          ]
//	 10%   246234  PUBG: BATTLEGROUNDS              [█▎          ]
//	  5%   123765  Grand Theft Auto V               [▋           ]
//	  3%    64405  Team Fortress 2                  [▍           ]
//	  1%    21228  The Sims™ 4                      [▏           ]
//	  0%     5564  Sekiro™: Shadows Die Twice       [            ]
func BarChart[M ~map[K]V, K cmp.Ordered, V Integer](w io.Writer, m M, maxItems int) {
	var total V
	keys := make([]K, 0, len(m))
	for k, v := range m {
		total += v
		keys = append(keys, k)
	}

	slices.SortFunc(keys, func(a, b K) int {
		return cmp.Compare(m[b], m[a])
	})

	if maxItems >= 0 && maxItems < len(keys) {
		keys = keys[:maxItems]
	}

	var maxKeyWidth int
	keyStrings := make([]string, len(keys))
	for i, k := range keys {
		s := keyString(k)
		keyStrings[i] = s
		if l := len([]rune(s)); l > maxKeyWidth {
			maxKeyWidth = l
		}
	}

	fmt.Fprintf(w, "100%%  %d  Total (%d entries)\n", total, len(m))
	maxValueWidth := 1 + int(math.Log10(float64(total)))
	for i, k := range keys {
		v := m[k]
		const maxBarWidth = 12 * 8 // 12 terminal characters for 100% values
		barWidth := int(math.Round(maxBarWidth * float64(v) / float64(total)))
		fmt.Fprintf(w, "%3.f%%  %*d  %-*s [%-*s]\n",
			100*float64(v)/float64(total),
			maxValueWidth, v,
			maxKeyWidth, keyStrings[i],
			12, UnicodeBar(barWidth),
		)
	}
}

// AppendByte appends the string form of the byte count i,
// as generated by FormatByte, to dst and returns the extended buffer.
func AppendByte[T Number](dst []byte, i T) []byte {
	if i < 0 {
		panic("negative byte count")
	}
	f := float64(i)
	var thousands int
	for ; math.Round(f) >= 1000; f /= 1000 {
		thousands++
	}
	var prec int
	if thousands > 0 {
		if d := math.Round(f * 10); d < 100 && int(d)%10 != 0 {
			prec = 1
		}
	}

	dst = strconv.AppendFloat(dst, f, 'f', prec, 64)
	dst = append(dst, ' ')
	if thousands > 0 {
		dst = append(dst, " kMGTPEZY"[thousands])
	}
	dst = append(dst, 'B')
	return dst
}

func FormatByte[T Number](i T) string {
	return string(AppendByte(make([]byte, 0, 6), i))
}

// MultiLines formats a multiline raw string, changing:
//
//	`
//		First line
//			Second line
//			Third line
//	`
//
// to:
//
//	`First line
//		Second line
//		Third line`
//
// It is intended to be called like this:
//
//	MultiLines(`
//		First Line
//			Second line
//			Third line
//	`)
func MultiLines(s string) string {
	lines := strings.Split(s, "\n")
	if len(lines) < 3 {
		panic("MultiLines: expected raw string enclosed with new lines")
	}
	lines = lines[1 : len(lines)-1]
	padding := 0
loop:
	for ; padding < len(lines[0]); padding++ {
		switch lines[0][padding] {
		case '\t', '\n', '\v', '\f', '\r', ' ':
		default:
			break loop
		}
	}
	for i, line := range lines {
		lines[i] = line[min(padding, len(line)):]
	}
	return strings.Join(lines, "\n")
}
